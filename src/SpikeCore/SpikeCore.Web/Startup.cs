using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Autofac;
using Autofac.Extensions.DependencyInjection;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.HttpOverrides;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Serilog;
using SpikeCore.Data;
using SpikeCore.Data.Models;
using SpikeCore.Irc;
using SpikeCore.Irc.Configuration;
using SpikeCore.Irc.Irc4NetButSmarter;
using SpikeCore.MessageBus.Foundatio.AutofacIntegration;
using SpikeCore.Modules;
using SpikeCore.Web.Configuration;
using SpikeCore.Web.Hubs;
using SpikeCore.Web.Services;
using SpikeCore.Web.TokenProviders;

namespace SpikeCore.Web
{
    public class Startup
    {
        private IConfiguration Configuration { get; }
        private WebConfig WebConfig { get; } = new WebConfig();

        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
            Configuration.GetSection("Web").Bind(WebConfig);
        }

        public void ConfigureServices(IServiceCollection services)
        {
            if (WebConfig.Enabled)
            {
                services.AddSignalR();

                services.Configure<CookiePolicyOptions>(options =>
                {
                    options.CheckConsentNeeded = context => true;
                    options.MinimumSameSitePolicy = SameSiteMode.None;
                });

                services.Configure<ForwardedHeadersOptions>(options =>
                {
                    options.ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto;
                });
                
                services.AddDatabaseDeveloperPageExceptionFilter();
            }

            services.AddDbContext<SpikeCoreDbContext>(options =>
            {
                options.UseSqlite(Configuration.GetConnectionString("SpikeCoreDbContextConnection"));
            });

            services
                .AddDefaultIdentity<SpikeCoreUser>(options =>
                {
                    options.Password.RequireDigit = false;
                    options.Password.RequireLowercase = false;
                    options.Password.RequireNonAlphanumeric = false;
                    options.Password.RequireUppercase = false;
                })
                .AddRoles<IdentityRole>()
                .AddEntityFrameworkStores<SpikeCoreDbContext>()
                .AddDefaultTokenProviders()
                .AddPasswordlessLoginTokenProvider()
                .AddUserStore<SpikeCoreUserStore>();

            if (WebConfig.Enabled)
            {
                services
                    .AddControllersWithViews();

                services.ConfigureApplicationCookie(options =>
                {
                    // Make sure our [Authorize] annotations bounce people to an access denied, instead of a login.
                    // Users can only login through special URLs generated by the bot.
                    options.LoginPath = "/Identity/Account/AccessDenied";
                });
            }

            services.AddHttpClient();
        }

        // ConfigureContainer is where you can register things directly
        // with Autofac. This runs after ConfigureServices so the things
        // here will override registrations made in ConfigureServices.
        // Don't build the container; that gets done for you by the factory.
        public void ConfigureContainer(ContainerBuilder containerBuilder)
        {
            // Register your own things directly with Autofac here. Don't
            // call builder.Populate(), that happens in AutofacServiceProviderFactory
            // for you.

            var ircConnectionConfig = new IrcConnectionConfig();
            Configuration.GetSection("IrcConnection").Bind(ircConnectionConfig);
            containerBuilder.RegisterInstance(ircConnectionConfig);

            var moduleConfiguration = new ModuleConfiguration();
            Configuration.GetSection("Modules").Bind(moduleConfiguration);
            containerBuilder.RegisterInstance(moduleConfiguration);

            containerBuilder
                .RegisterFoundatio();

            // Register this as a singleton so both our modules and ASP.NET infrastructure get the same instance.
            // Removing this causes our modules and controllers to get different instances of a UserManager, which, 
            // due to EF means that making updates via one is not available to the other.
            containerBuilder.RegisterType<UserManager<SpikeCoreUser>>()
                .As<UserManager<SpikeCoreUser>>()
                .PropertiesAutowired()
                .SingleInstance();

            containerBuilder
                .RegisterType<IrcConnection>()
                .As<IIrcConnection>()
                .SingleInstance();

            containerBuilder
                .RegisterType<IrcClient>()
                .As<IIrcClient>()
                .PropertiesAutowired()
                .SingleInstance();

            containerBuilder
                .RegisterType<SignalRMessageBusConnector>()
                .As<ISignalRMessageBusConnector>()
                .SingleInstance();

            containerBuilder
                .RegisterType<LoggingListener>()
                .SingleInstance();

            containerBuilder
                .RegisterAssemblyTypes(typeof(IModule).Assembly)
                .Where(t => t.Name.EndsWith("Module"))
                .As<IModule>()
                .PropertiesAutowired()
                .SingleInstance();

        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            var container = app.ApplicationServices.GetAutofacRoot();

            // Grab an instance of IBot so that it gets activated.
            // We don't need to keep hold of it, it's a singleton.
            // Using AutoActivate meant RegisterFoundatio wasn't able to hook Activated before activation.
            container.Resolve<IIrcConnection>();

            // We also need to resolve all of our modules.
            container.Resolve<IEnumerable<IModule>>();
            container.Resolve<LoggingListener>();

            if (WebConfig.Enabled)
            {
                if (env.IsDevelopment())
                {
                    app.UseDeveloperExceptionPage();
                    app.UseMigrationsEndPoint();
                }
                else
                {
                    app.UseExceptionHandler("/Home/Error");
                    app.UseHsts();
                }

                if (!string.IsNullOrEmpty(WebConfig.PathBase))
                {
                    // If our proxy trims the path, configure our requests appropriately.
                    Log.Information("Setting the PathBase to {PathBase}", WebConfig.PathBase);
                    app.Use((context, next) =>
                    {
                        context.Request.PathBase = new PathString(WebConfig.PathBase);
                        return next();
                    });
                }

                app.UseHttpsRedirection();
                app.UseStaticFiles();
                app.UseCookiePolicy();

                app.UseRouting();

                app.UseAuthentication();
                app.UseAuthorization();

                app.UseEndpoints(endpoints =>
                {
                    endpoints.MapHub<BotConsoleHub>("/hubs/bot-console");
                    endpoints.MapControllerRoute(
                        name: "default",
                        pattern: "{controller=Home}/{action=Index}/{id?}");
                    endpoints.MapRazorPages();

                    // Disable registration - user management only happens via the bot.
                    endpoints.MapGet("/Identity/Account/Register", context =>
                        {
                            context.Response.Redirect("/Identity/Account/AccessDenied", true, true);
                            return Task.CompletedTask;
                        }
                    );

                    endpoints.MapPost("/Identity/Account/Register", context =>
                        {
                            context.Response.Redirect("/Identity/Account/AccessDenied", true, true);
                            return Task.CompletedTask;
                        }
                    );
                });
            }
        }
    }
}
